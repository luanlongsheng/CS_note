# 面试笔试算法习题

- **时间复杂度：算法的执行时间与输入值之间的关系**

  O(1) > O(logn) > O(n) > O(nlogn) > O(n^2^) (看循环，二分，嵌套)

- **空间复杂度：算法的存储空间与输入值之间的关系**

  O(1)， O(n)

  递归一般是O(n)

### 一、常见的模拟贪心与枚举

##### 1.两数之和

**习题：Leetcode167**

> 题目描述
>
> 给定一个从小到大的数据和一个目标数t，在其中找到两个数，使两数之和与目标数相同

解题方法：

- 暴力O(n^2^)
- 二分查找O(nlogn)
- 哈希表O(n) (时间复杂度与空间复杂度)
- 双指针法O(n)

双指针法代码演示

```c++
#include <iostream>
#include <stdio.h>
using namespace std;

int num[10000];

int main () {
    int n, t;
    scanf("%d%d", &n, &t);
    int l = 0, r = n - 1;
    for (int i = 0; i < n; i++) {
        scanf("%d", &num[i]);
    }

    while (l < r) {
        if (num[l] + num[r] == tmp) {
            cout << i << " " << l << " " << r << endl;
            return 0;
        }
        if (num[l] + num[r] > t) {
            r--;
        } else {
            l++;
        }
    }
    
    cout << -1 << endl;
    return 0;
}
```

扩展：如何求三数之和呢？可以每次先固定一个数，然后其余的数再利用双指针法遍历一遍，这样时间复杂度为O(n)，代码如下

```c++
#include <iostream>
#include <stdio.h>
using namespace std;

int num[10000];

int main () {
    int n, t;
    scanf("%d%d", &n, &t);
    int l = 0, r = n - 1;
    for (int i = 0; i < n; i++) {
        scanf("%d", &num[i]);
    }
    for (int i = 0; i < n; i++) {
        int tmp = t;
        tmp = t - num[i];
        l = i + 1, r = n - 1;
        while (l < r) {
            if (num[l] + num[r] == tmp) {
                cout << i << " " << l << " " << r << endl;
                return 0;
            }
            if (num[l] + num[r] > t) {
                r--;
            } else {
                l++;
            }
        }
    }

    cout << -1 << endl;
    return 0;
}
```

##### 2.杨氏矩阵

**参考习题：oj600**

在杨氏矩阵中搜索目标数，返回下标

| 1    | 2    | 3    | 4    |
| ---- | ---- | ---- | ---- |
| 5    | 6    | 15   | 20   |
| 7    | 10   | 20   | 25   |

- 暴力求解 O(m * n)

- 双指针，从左下角或右上角开始遍历，一个指针x指向行，一个指针y指向列，

  若目标值大于当前元素:y++

  若目标值小于当前元素:x--

  直到目标元素=当前元素，返回下标

  这种方法的时间复杂度为O(m+n)

```c++
#include <iostream>
using namespace std;

int num[3005][3005];

int main() {
    int n, m, t;
    cin >> n >> m >> t;
    int num[n][m];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> num[i][j];
        }
    }

    int x = n - 1, y = 0;

    while (x >= 0 && x < n && y >= 0 && y < m) {
        if (num[x][y] == t) {
            cout << x << " " << y << endl;
            return 0;
        }
        if (num[x][y] < t) y++;
        else x--;
    }

    cout << "error" << endl;

    return -1;
}
```

##### 3.乒乓球计分

**习题：oj479**

```c++
#include <iostream>
#include <cmath>
using namespace std;

int a11[6000][2], a21[3000][2], ind1, ind2;

void p() {
    for (int i = 0; i <= ind1; i++) {
        cout << a11[i][0] << ":" << a11[i][1] << endl;
    }
    cout << endl;
    for (int i = 0; i <= ind2; i++) {
        cout << a21[i][0] << ":" << a21[i][1] << endl;
    }
}

int main() {
    char s[30];
    while (cin >> s) {
        for (int i = 0; s[i]; i++) {
            if (s[i] == 'E') {
                p();
                return 0;
            }
            if (s[i] == 'W') {
                a11[ind1][0]++;
                a21[ind2][0]++;
            } else {
                a11[ind1][1]++;
                a21[ind2][1]++;
            }
            if ((a11[ind1][0] >= 11 || a11[ind1][1] >= 11) && abs(a11[ind1][0] - a11[ind1][1]) >= 2) {
                ind1++;
            }
            if ((a21[ind2][0] >= 21 || a21[ind2][1] >= 21) && abs(a21[ind2][0] - a21[ind2][1]) >= 2) {
                ind2++;
            }
        }
    }
    return 0;
}
```

##### 4.冰壶比赛

**习题：oj481**

```c++
#include <iostream>
#include <algorithm>
using namespace std;

int r, ans[15][2];//ans中存放每一局比赛中两个队伍的得分情况

void p(int n) {
    int a1 = 0, a2 = 0;
    for (int i = 1; i < n; i++) {
        a1 += ans[i][0];
        a2 += ans[i][1];
        cout << ans[i][0] << ":" << ans[i][1] << endl;
    }
    cout << a1 << ":" << a2 << endl;
}

int main() {
    cin >> r;
    for (int i = 1; i <= 10; i++) {
        int num1[10] = {0}, num2[10] = {0};
        for (int j = 0; j < 8; j++) {
            cin >> num1[j];
            if (num1[j] == -1) {
                p(i);
                return 0;
            }
        }
        for (int j = 0; j < 8; j++) {
            cin >> num2[j];
        }
        sort(num1, num1 + 8);
        sort(num2, num2 + 8);
        if (num1[0] < num2[0]) {
            for (int j = 0; j < 8; j++) {
                if (num1[j] > r || num1[j] >= num2[0]) break;
                ans[i][0]++;
            } 
        } else {
            for (int j = 0; j < 8; j++) {
                if (num2[j] > r || num2[j] >= num1[0]) break;
                ans[i][1]++;
            } 
        }
    }
    p(11);

    return 0;
}
```

##### 5.柱状统计图

**习题：oj484**

```c++
#include <iostream>
using namespace std;

int num[130];
char str[1005];

int main() {
	while (cin >> str) {//循环读入字符串，ctrl+D结束循环
		for (int i = 0; str[i]; i++) {//统计每一个字符出现的次数
			num[str[i]]++;
		}
	}
	
	int mmax = 0;
	for (int i = 'A'; i <= 'Z'; i++) {//统计最大次数
		mmax = max(mmax, num[i]);
	}
	
	int ind
	for (int i = mmax; i > 0; i--) {
		for (int j = 'Z'; j >= A; j--) {//统计出现最多次数元素的下标
			if (num[j] >= mmax) {
				ind = j;
				break;
			}
		}
		
		for (int j = 'A'; j <= 'Z'; j++) {//按格式输出
			j != 'A' && cout << " ";
			if (num[j] >= i) {
				cout << "*";
			} else {
				cout << " ";
			}
		}
		cout < endl;
	}
	
	for (char i = 'A'; i <= 'Z'; i++) {//输出最后一行
		i != 'A' && cout << " ";
		cout << i;
	}
	cout << endl;
	
	return 0;
}
```

##### 6.均分纸牌

**习题：oj485**

```c++
#include <iostream>
using namespace std;

int n, num[105], ans, sum, arg;

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> num[i];
        sum += num[i];
    }
    arg = sum / n;
    for (int i = 0; i < n - 1; i++) {
        if (num[i] != arg) {
            ans++;
            num[i + 1] += (num[i] - arg);
        }
    }
    cout << ans << endl;
    return 0;
}
```

##### 7.删数

**习题：oj504**

- string中的方法

```c++
str.size(); //获取字符串的长度
str.replace(ind, 1, ""); //string类中的一个方法，可以将索引位置处的值替换，将长度为１的空间替换为空则是删掉
```

```c++
#include <iostream>
#include <string>
using namespace std;

string str;
int n;

int main() {
    cin >> str >> n;
    for (int i = 0; i < n; i++) {
        int ind = str.size() - 1;//初始删除最后一位
        for (int j = 0; j < str.size() - 1; j++) {
            if (str[j] > str[j + 1]) {
                ind = j;
                break;
            }
        }
        str.replace(ind, 1, "");//string类中的一个方法，可以将索引位置处的值替换，将长度为１的空间替换为空则是删掉
    }

    int f = 0;
    for (int i = 0;  i < str.size(); i++) {
        if (str[i] != '0') {
            f = 1;
        }
        if (f) {
            cout << str[i];
        }
    }
    cout << endl;
    return 0;
}
```

##### 8.最大整数

**习题：oj505**

- sort的用法

> c++标准库里的排序函数的使用方法
>
> I）Sort函数包含在头文件为#include<algorithm>的c++标准库中，调用标准库里的排序方法可以不必知道其内部是如何实现的，只要出现我们想要的结果即可！
>
> II）Sort函数有三个参数：
>
> （1）第一个是要排序的数组的起始地址。
>
> （2）第二个是结束的地址（最后一位要排序的地址）
>
> （3）第三个参数是排序的方法，可以是从大到小也可是从小到大，还可以不写第三个参数，此时默认的排序方法是从小到大排序。
>
> Sort函数使用模板:
>
> Sort(start,end,排序方法)

```c++
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

string s[100005];
int n;

bool cmp(const string &a, const string &b) {
    return a + b > b + a;
}

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> s[i];
    }
    sort(s, s + n, cmp);

    for (int i = 0; i < n; i++) {
        cout << s[i];
    }
    cout << endl;
    
    return 0;
}
```

##### 9.两人过河问题

**习题：oj508**

```c++
#include <iostream>
#include <algorithm>
using namespace std;

int n, num[1005], ans;

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> num[i];
    }
    sort(num, num + n);


    for (int i = n; i > 0; i -= 2) {//每轮循环确保带两个人过河,分情况讨论
        if (i == 1) {
            ans += num[0];
            break;
        } else if (i == 2) {
            ans += num[1];
            break;
        } else if (i == 3) {
            ans += num[2] + num[1] + num[0];
            break;
        } else {//n >= 4每轮循环确保带两个人过河，取以传手电和过桥效率高两种方式用时的最小值
            ans += min(num[i - 1] + num[0] + num[i - 2] + num[0], num[1] + num[0] + num[i - 1] + num[1]);
        }
        
    }
    cout << ans << endl;
    return 0;
}
```

### 二、STL的使用

##### 1.队列 queue

- 创建队列：`queue<int> que`

- 操作

|          方法           |    程序     |
| :---------------------: | :---------: |
|          入队           | que.push()  |
|          出队           |  que.pop()  |
|      获得队首元素       | que.front() |
|    获得队列元素个数     | que.size()  |
| 判断队列是否为空(1为空) | que.empty() |

- 自定义类型

```c++
#include <iostream>
#include <queue>
using namespace std;

struct node {
    int x, y;
};

int main() {
    queue<node> que;
    node a;
    a.x = a.y = 6;
    que.push(a);
    que.push((node){7, 8});
    cout << que.front().x << endl;//6
    que.pop();
    node temp = que.front();
    cout << temp.x << " " << temp.y << endl;//7 8
    return 0;
}
```

##### 2.栈 stack

- 创建栈：`stack<int> s`
- 操作

|         方法          |   程序    |
| :-------------------: | :-------: |
|         入栈          | s.push()  |
|         出栈          |  s.pop()  |
|     获得栈顶元素      |  s.top()  |
|   获得栈中元素个数    | s.size()  |
| 判断栈是否为空(1为空) | s.empty() |

- 总结

队列和栈的底层实现都是通过一个双端队列

双端队列就是一个数组，两头都可以入出，故有四种操作

如果将头部出口堵住，则只能从尾部入出，这时就成了栈

如果将头部进和尾部出堵住，就变成了队列

- 示例代码

```c++
#include <iostream>
#include <stack>
using namespace std;

int main() {
    stack<int> s;
    for (int i = 9; i > 4; i--) {
        s.push(i);
    }
    while (!s.empty()) {
        cout << "s.top() = " << s.top() << "\ts.size() = " << s.size() << endl;
        s.pop();
    }
    return 0;
}
```

- 习题

oj569溶液模拟器

```c++
#include <iostream>
#include <stack>
#include <cstdio>
using namespace std;

struct node {
    double s, ws;//溶质质量和总质量
};

int main() {
    double ws0, c0, s0;//初始的溶液质量、浓度、溶质质量
    cin >> ws0 >> c0;
    s0 = ws0 * c0 / 100;
    int n;
    cin >> n;
    stack<node> sta;
    for (int i = 0; i < n; i++) {
        char t;
        cin >> t;
        if (t == 'P') {
            double wst, ct, st;//某次添加的质量
            cin >> wst >> ct;
            st = wst * ct / 100;
            ws0 += wst;
            s0 += st;
            sta.push((node){st, wst});
        } else {
            if (!sta.empty()) {
                ws0 -= sta.top().ws;
                s0 -= sta.top().s;
                sta.pop();
            }
        }
        printf("%d %.5f\n", (int)ws0, s0 / ws0 * 100);
    }
    return 0;
}
```

##### 3.动态数组 vector

- 创建数组`vector<int> v`

  初始化：(一个参数)表示元素的个数，（两个参数）第一个表示元素的个数，第二个表示元素是什么

- 创建动态二维数组`vector<vector<int> > v`
  初始化：（一个参数）表示元素的个数，（两个参数）第一个表示元素的个数，第二个表示元素都是什么

  (5, vector<int>())

- 操作

|       代码        |   操作   |
| :---------------: | :------: |
| v.push_back(元素) | 插入元素 |
|     v.size()      | 数组大小 |
|   v.insert(1,6)   | 插入元素 |

> v.push_back()的时间复杂度是O(1)
>
> v.insert()的时间复杂度是O(n)

> vector的底层用的一段连续的空间实现

- 示例代码

动态二维数组

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    /*
    vector<int> v;
    for (int i = 105;i <= 110; i++) {
        v.push_back(i);
        cout << v.size() << endl;
    }
    for (int i = 0; i < v.size(); i++) {
        cout << v[i] << endl;
    }*/
    vector<vector<int> > v;
    v.push_back(vector<int>());
    for (int i = 66; i <= 70; i++) {
        v[0].push_back(i);
    }
    v.push_back(vector<int>(5, 0));
    vector<int> v2;
    v2.push_back(5);
    v2.push_back(6);
    v2.push_back(7);
    v.push_back(v2);
    v.push_back(vector<int>(10, 0));
    for (int i = 0; i < v.size(); i++) {
        for (int j = 0; j < v[i].size(); j++) {
            cout << v[i][j] << "\t";
        }
        cout << endl;
    }
    return 0;
}
```

##### 4.优先队列 priority_queue

- 创建优先队列：`priority_queue<int> que`

`priority_queue< type, container, function >`

- 操作

|    代码     |     操作     |
| :---------: | :----------: |
| que.push()  |   插入元素   |
|  que.pop()  |   弹出元素   |
|  que.top()  |   堆顶元素   |
| que.size()  |  堆元素个数  |
| que.empty() | 判断是否为空 |

- 默认为大顶堆，通过修改优先队列可以使其为小顶堆

- 示例

优先队列演示

```c++
#include <iostream>
#include <queue>
#include <cstdlib>
#include <ctime>
using namespace std;

struct node {
    int x, y;
    double z;
    bool operator< (const node &b) const {
        return this->x > b.x;
    }
};

int main() {
    srand(time(NULL));
    priority_queue<int> que;
    #define max_op 10
    for (int i = 0; i < max_op; i++) {
        int val = rand() % 100;
        que.push(val);
        cout << "val = " << val << endl;
    }
    while (!que.empty()) {
        cout << que.top() << " ";
        que.pop();
    }
    cout << endl;
    return 0;
}
```

自定义类型

```c++
#include <iostream>
#include <queue>
#include <cstdlib>
#include <ctime>
using namespace std;

struct node {
    int x, y;
    double z;
    bool operator< (const node &b) const {//重载运算符，使其从小到达排序
        return this->x > b.x;//让<实现大于的功能，这时相当于构建了一个小顶堆
    }
};

int main() {
    priority_queue<node> que;
    que.push((node){1, 2, 4.5});
    que.push((node){2, 1, 5.6});
    cout << que.top().x << endl;
    que.pop();
    cout << que.top().x << endl;
    return 0;
}
```

##### 5.字符串 string

- 创建字符串 `string str`

- 操作

|                      代码                      |              操作              |
| :--------------------------------------------: | :----------------------------: |
|            str.size() / str.length             |              长度              |
| str.find(s2)第二个参数默认为0,表示查找起始位置 |         在str中查找s2          |
|               str.insert(x, s2）               |         在x位置插入s2          |
|                 str.substr(2)                  |      从下标为2截取到最后       |
|                str.substr(2,4)                 |     第二个参数表示截取长度     |
|             str.replace(x, y, s2)              | 从x位置开始替换长度y个字符为s2 |

```c++
string a = "123" + "a";
a += "123";
```

##### 6.键值对 map

- 创建键值对 `map<string, int> m`
- 操作

赋值：`m["123"] = 456`

如果访问一个不存在的键值，则会添加一个键值，并且为该键赋一个默认的值，整型为0，字符型为空

|     操作     |     程序     |
| :----------: | :----------: |
|     插入     |    insert    |
|     查找     |     find     |
|     删除     |    earse     |
| 判断是否为空 | 直接输出cout |

底层实现：红黑树

排序是按照键进行排序，和值无关。

如果对自定义类型进行排序，则需要重载运算符

时间复杂度：O(n)

- unordered_map

底层实现：哈希表

时间复杂度：O(1)

编译时需要加C++11标准`g++ 1.cpp -std=c++11`

操作和map类似

如果需要进行排序的话，则需要自己构建哈希表

所以一般在自定义结构的情况下使用map

不需要自定义结构的情况使用unordere_map

- 示例代码

```c++
#include <iostream>
#include <map>
#include <string>
using namespace std;

int main() {
    map<string, int> m;
    string a = "123";
    m[a] = 999;
    cout << m["123"] << endl;
    cout << m[a] << endl;
    cout << m["456"] << endl;
    return 0;
}
```

自定义类型，需要重载运算符

```c++
#include <iostream>
#include <map>
#include <string>
using namespace std;

struct node {
    int x, y;
    bool operator< (const node &b) const {
        return this->x > b.x;
    }
};

int main() {
    map<node, int> m;
    node a;
    m[a] = 5;
    return 0;
}
```

##### 7.集合 set

集合中元素只出现一次，可以做去重加排序操作

底层实现哈希表

##### 8.对 pair

把两个东西捆在一起成为一个东西

`pair<int, int>`

访问第一个元素`.first`

访问第二个元素`.second`

##### 9.总结

|      结构      |   底层实现   |
| :------------: | :----------: |
|     queue      |   双端队列   |
|     stack      |   双端队列   |
|     vector     | 连续内存空间 |
| priority_queue |      堆      |
|      map       |    红黑树    |
|      set       |    红黑树    |

### 三、排列组合与搜索走地图问题

##### 1.递归实现指数型枚举

- 题目描述

> 从1−n 这 n 个整数中随机选取任意多个，每种方案里的数从小到大排列，按字典序输出所有可能的选择方案。

输入: 输入一个整数 n。（1≤n≤10）

输出:

 每行一组方案，每组方案中两个数之间用空格分隔。

 注意每行最后一个数后没有空格。

------

样例输入

```
3
```

样例输出

```
1
1 2
1 2 3
1 3
2
2 3
3
```

- 示例代码

```c++
#include <iostream>
using namespace std;

int num[15], n, cnt; //cnt表示第几层

void p() {
    for (int i = 0; i <= cnt; i++) {
        i && cout << " ";
        cout << num[i];
    }
    cout << endl;
}

void func(int s) {
    for (int i = s; i <= n; i++) {
        num[cnt] = i;
        p();
        cnt++; //回溯
        func(i + 1);
        cnt--;
    }
}

int main() {
    cin >> n;
    func(1);
    return 0;
}

```

##### 2.递归实现组合型枚举
- 题目描述

从 1−n 这 n 个整数中随机选取m 个，每种方案里的数从小到大排列，按字典序输出所有可能的选择方案。

输入

 输入两个整数n,m。（1≤m≤n≤10）

输出

 每行一组方案，每组方案中两个数之间用空格分隔。

 注意每行最后一个数后没有空格。

------
样例输入

```
3 2
```

样例输出

```
1 2
1 3
2 3
```

- 示例代码

```c++
#include <iostream>
using namespace std;

int n, m, num[15], cnt;

void p() {
    for (int i = 0; i < cnt; i++) {
        i && cout << " ";
        cout << num[i];
    }
    cout << endl;
}

void func(int s, int left) { //s代表从第几个元素开始，left代表剩余多少元素
    if (left == 0) {
        p();
        return ;
    }
    for (int i = s; i <= n; i++) {
        num[cnt] = i;
        cnt++;
        func(i + 1, left - 1);
        cnt--;
    }
}

int main() {
    cin >> n >> m;
    func(1, m);
    return 0;
}
```

- 扩展问题

是否可以求出一个指定的长度为100的数组中任意五个元素的和有多少种

> 可以先求出100中取出5个元素的所有组合情况，然后根据下标索引值进行求和

##### 3.递归实现排列型枚举

- 题目描述

 从 1−n 这n 个整数排成一排并打乱次序，按字典序输出所有可能的选择方案。

输入

 输入一个整数 *𝑛*n。（1≤*𝑛*≤8）（1≤n≤8）

输出

 每行一组方案，每组方案中两个数之间用空格分隔。

 注意每行最后一个数后没有空格。

样例输入

```
3
```

样例输出

```
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

- 示例代码

```c++
#include <iostream>
using namespace std;

int num[15], n, cnt, mark[15];

void p() {
    for (int i = 0; i < n; i++) {
        i && cout << " ";
        cout << num[i];
    }
    cout << endl;
}

void func(int left) {
    if (left == 0) {
        p();
        return ;
    }

    for (int i = 1; i <= n; i++) {
        if (!mark[i]) {
            mark[i] = 1;
            num[cnt] = i;
            cnt++;
            func(left - 1);
            cnt--;
            mark[i] = 0;
        }
    }
}

int main() {
    cin >> n;
    func(n);
    return 0;
}
```

- 扩展问题：先组合，再排列

##### 4.深搜

**常用解决问题：解决地图上哪些点是相连的，相连的点数量是多少，解决连通性问题**

- 搜索走地图问题

- 给定一个地图，其中有一些障碍物（不能走的地方），判断最终能不能由起点走向终点。

  - 方向数组
  - 存地图，从(1,1)点开始存，边界点都为0，这样就不用判断边界了

  每次拿到一个点，并以这个点为起点进行搜索

  ```c++
  #include <iostream>
  using namespace std;
  
  int n, m, sx, sy;
  char mmap[105][105];
  int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};//方向数组
  
  int func(int x, int y) {
      for (int i = 0; i < 4; i++) {//遍历四个方向
          int xx = x + dir[i][0];
          int yy = y + dir[i][1];
          if (mmap[xx][yy] == 'T') {
              return 1;
          }
          if (mmap[xx][yy] == '.') {
              mmap[xx][yy] = '#';//去重
              if (func(xx, yy) == 1) {
                  return 1;
              }
          }
      }
      return 0;
  }
  
  int main() {
      cin >> n >> m;
      for (int i = 1;i <= n; i++) {
          for (int j = 1; j <= m; j++) {
              cin >> mmap[i][j];
              if (mmap[i][j] == 'S') {
                  sx = i, sy = j;//确定起点位置
              }
          }
      }
      if (func(sx, sy) == 1) {
          cout << "YES" << endl;
      } else {
          cout << "NO" << endl;
      }
      return 0;
  }
  ```

  ```
  In:
  	S...
  	##..
  	##..
  	T...
  Out:
  	YES
  ```

- oj396填涂颜色

**题目描述**

>  由数字 00 组成的方阵中，有一任意形状闭合圈，闭合圈由数字 11 构成，围圈时只走上下左右 44 个方向。现要求把闭合圈内的所有空间都填写成 22。例如：6×66×6 的方阵 （*𝑛*=6）（n=6），涂色前和涂色后的方阵如下：
>
> ```
> In:
> 0 0 0 0 0 0
> 0 0 1 1 1 1
> 0 1 1 0 0 1
> 1 1 0 0 0 1
> 1 0 0 0 0 1
> 1 1 1 1 1 1
> Out:
> 0 0 0 0 0 0
> 0 0 1 1 1 1
> 0 1 1 2 2 1
> 1 1 2 2 2 1
> 1 2 2 2 2 1
> 1 1 1 1 1 1
> ```

- 深搜示例代码

```c++
#include <iostream>
using namespace std;

int n, m;
int mmap[105][105];
int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};

void dfs(int x, int y) {
    for (int i = 0; i < 4; i++) {
        int xx = x + dir[i][0];
        int yy = y + dir[i][1];

        if (xx < 0 || yy < 0 || xx > n + 1 || yy > n + 1) continue;
        if (mmap[xx][yy] == 0) {
            mmap[xx][yy] = 3;
            dfs(xx, yy);
        }

    }
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> mmap[i][j];
        }
    }
    mmap[0][0] = 3;
    dfs(0, 0);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            j != 1 && cout << " ";
            if (mmap[i][j] == 3) {
                cout << 0; 
            } else if (mmap[i][j] == 0) {
                cout << 2;
            } else {
                cout << 1;
            }
        }
        cout << endl;
    }
    return 0;
}
```

##### 5.广搜

**常用解决问题：从起点到终点需要多少步**

广搜需要用到一个搜索队列，

广搜问题也可以抽象成一颗N叉树，不过它的遍历顺序是层序遍历。

先将第一个元素放入队列，每次访问队首元素，将队首元素拿出来，然后将其子孩子加入到队列中，每次继续拿出队首元素，然后将队首元素的子孩子加入到栈中，依次类推，一直到队首元素没有子孩子，弹出队列内所有元素到队内没有元素。

- 搜索走地图问题

  因为是层序遍历，所以最先到达终点的步数一定是最短的。

- 需要一个结构体存放当前坐标及步数

  ```c++
  struct node {
  	int x, y, step;
  }
  ```

- 用广搜解决搜索走地图问题

```c++
#include <iostream>
#include <queue>
using namespace std;

struct node {
    int x, y, step;
};

int n, m, sx, sy;
int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
char mmap[105][105];

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> mmap[i][j];
            if (mmap[i][j] == 'S') {
                sx = i, sy = j;
            }
        }
    }
    queue<node> que;
    que.push((node){sx, sy, 0});
    while (!que.empty()) {
        node temp = que.front();
        que.pop();
        for (int i = 0; i < 4; i++) {
            int x = temp.x + dir[i][0];
            int y = temp.y + dir[i][1];
            if (mmap[x][y] == 'T') {
                cout << temp.step + 1;
                return 0;
            }
            if (mmap[x][y] == '.') {
                mmap[x][y] = 0;
                que.push((node){x, y, temp.step + 1});
            }
        }
    }
    cout << "NO" << endl;
    return 0;
}
```

- oj396广搜版

```c++
#include <iostream>
#include <queue>
using namespace std;

struct node {
    int x, y;
};

int n, m, mmap[105][105];
int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> mmap[i][j];
        }
    }
    queue<node>que;
    que.push((node){0, 0});
    mmap[0][0] = 3;
    while (!que.empty()) {
        node temp = que.front();
        que.pop();
        for (int i = 0; i < 4; i++) {
            int x = temp.x + dir[i][0];
            int y = temp.y + dir[i][1];
            if (x < 0 || y < 0 || x > n + 1 || y > n + 1 || mmap[x][y] == 3) continue;
            if (mmap[x][y] == 0) {
                mmap[x][y] = 3;
                que.push((node){x, y});
            }
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            j != 1 && cout << " ";
            if (mmap[i][j] == 3) {
                cout << 0;
            } else if (mmap[i][j] == 0) {
                cout << 2;
            } else {
                cout << 1;
            }
        }
        cout << endl;
    }

    return 0;
}
```

- oj304骑士风度的牛

**题目亮点：方向数组的应用、如何处理边界条件**

**题目描述：由K走日字到H的最短路径**

#### 样例输入

```
10 11
..........
....*.....
..........
...*.*....
.......*..
..*..*...H
*.........
...*...*..
.K........
...*.....*
..*....*..
```

#### 样例输出

```
5
```

**示例代码**

```c++
#include <iostream>
#include <queue>
using namespace std;

struct node {
    int x, y, step;
};

int n, m;
int dir[8][2] = {1, 2, 1, -2, -1, 2, -1, -2, 2, 1, 2, -1, -2, 1, -2, -1};//8个方向
char mmap[200][200];

int main() {
    cin >> m >> n;
    queue<node>que;
    for (int i = 5; i < n + 5; i++) {//向外填充5个0，避免跳的过程越界
        for (int j = 5; j < m + 5; j++) {
            cin >> mmap[i][j];
            if (mmap[i][j] == 'K') {
                que.push((node){i, j, 0});
            }
        }
    }
    while(!que.empty()) {
        node temp = que.front();
        que.pop();
        for (int i = 0; i < 8; i++) {
            int x = temp.x + dir[i][0];
            int y = temp.y + dir[i][1];
            if (mmap[x][y] == 'H') {
                cout << temp.step + 1 << endl;
                return 0;
            }
            if (mmap[x][y] == '.') {
                mmap[x][y] = '#';
                que.push((node){x, y, temp.step + 1});
            }
        }
    }
    cout << -1 << endl;
    return 0;
}
```

### 四、从递推到动归

##### 1. 递推问题

1. 确定递推状态y=f(n)

   一个数学符号加一个数学符号的语义解释

   分析自变量和因变量之间的关系,n为问题中的自变量，y为问题中的求解量

2. 确定递推公式

   推导递推状态符号的自我表示方法

   - 容斥原理

   将f(n)进行分解，分成互不相交的几部分，然后确定其中每一部分的f(n)表达式

3. 程序实现

   正向递归+记忆化或者循环

**例1**：**墙壁涂色问题**

**法一：**

1. 确定递推状态

   因变量：方法总数

   自变量：墙壁数量、头尾墙壁颜色f(n, i, j)

   解题技巧：可以先将墙壁当做一个非成环的问题，然后计算涂色总数，最后将首尾颜色相同的情况去掉，故我们在记录数据时自变量应加上头尾墙壁颜色

2.  确定递推公式

       不考虑成环情况：$f(n, i, j) = \sum_k {f(n-1, i, k) | (k  != j)}$
    
       考虑成环（去掉首尾颜色相同的情况）：$\sum_i\sum_j f(n, i, j) | (i != j)$

**法二：**

1. 确定递推状态

   由于在法一中，我们f(3, 2, 3)与f(3, 1, 3)的方法数其实是一样的，所以这里可以减小一维

​	   这时递推公式为f(n, j)，就代表墙壁数为$n$，然后首涂颜色0，尾涂颜色j的方法总数

2. 确定递推公式

   不考虑成环情况：$f(n, i, j) = \sum_k {f(n-1,k) | (k  != j)}$

   考虑成环（去掉首尾颜色相同的情况）：$\sum_i\sum_j f(n, j) * (n - 1) | (i != j)$  (这里n-1代表的是首墙壁涂颜色的种类数)

**法三：**

|  1   | ........ |  2   |  3(倒数第二个位置)  |  4   |
| :--: | :------: | :--: | :-----------------: | :--: |
|  1   | ........ |  2   | 3（倒数第二个位置） |  4   |

1. 确定递推状态

   f(n) 代表首尾颜色不同的方案总数

2. 确定递推公式

   f(n) = f(n - 1) * (k - 2) + f(n - 2) * (k - 1)

公式由来：对于第n面墙，可以分为两种可能的情况

​	情况1：位置1和3的颜色不同，这种情况正好等于f(n-1) * (k-2)，也就是前n-1面墙壁所有可能的情况, 并且此时4				  位置的墙壁不能和1,3位置处的颜色相同，还有k-2种可能

​	情况2：位置1和3的颜色相同，这种情况正好等于f(n-2) * (k-1)，也就是前n-2面墙壁所有可能 的情况，并且此4

​				  位置的墙壁不能和1,3位置处的颜色相同，还有k-1种可能

故情况1和情况2所有可能的情况总和为$f(n)=f(n-1)*(k-2)+f(n-2)*(k-1)$

```c++
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string>
#include <map>
#include <vector>
using namespace std;
//数据结构部分，封装大整数
class BigInt : public vector<int> {
public :
    BigInt() {
        push_back(0);
    }
    BigInt(int x) {
        push_back(x);
        proccess_digit();
    }
    BigInt operator*(int x) {
        BigInt ret(*this);
        ret *= x;
        return ret;
    }
    void operator*=(int x) {
        for (int i = 0; i < size(); i++) at(i) *= x;
        proccess_digit();
        return ;
    }
    void operator+=(const BigInt &num) {
        for (int i = 0; i < num.size(); i++) {
            if (i == size()) push_back(num[i]);
            else at(i) += num[i];
        }
        proccess_digit();
        return ;
    }
    BigInt operator+(const BigInt &num) {
        BigInt ret(*this);
        ret += num;
        return ret;
    }
    void proccess_digit() {
        for (int i = 0; i < size(); i++) {
            if (at(i) < 10) continue;
            if (i + 1 == size()) push_back(0);
            at(i + 1) += at(i) / 10;
            at(i) %= 10;
        }
        return ;
    }
};

ostream &operator<<(ostream &out, const BigInt &num) {
    for (int i = num.size() - 1; i >= 0; --i) {
        out << num[i];
    }
    return out;
}
//算法部分
int main() {
    int n, k;
    cin >> n >> k;
    BigInt f[3] = {0};
    f[1] = k; //只有1面墙
    f[2] = k * (k - 1);//2面墙
    f[0] = k * (k - 1) * (k - 2);//3面墙
    for (int i = 4; i <= n; i++) {//从4面墙开始计算，计算到第n面
        f[i % 3] = f[(i - 1) % 3] * (k - 2) + f[(i - 2) % 3] * (k - 1);
    }
    cout << f[n % 3] << endl;//输出第n面的结果
    return 0;
}
```

##### 2. 动归问题

动归可以看做一种为了求解最优解的一种特殊形式的递归问题

所以也可以按照三步走的步骤

**问题1：数字三角形**

> 问题描述：求解三角形从顶部到底部加和最大的一条路径

**思路一：从下向上推**

1. 确定递推状态

   f(i, j) 代表从底边走到(i, j)点所能获得的最大值

2. 确定递推公式

   f(i, j) = max[f(i+1, j), f(i+1, j+1)]+val(i, j)

   不需要做边界判断

**思路二：从上向下推**

1. 确定递推状态

   f(i, j) 代表从顶点走到(i, j)点所能获得的最大值

2. 确定递推公式

   f(i, j) = max[f(i-1, j), f(i-1, j-1)] + val(i, j)

   需要做边界判断



**数学归纳法**

1. 验证k~0~成立
2. 证明如果k~0~成立，那么k~i+1~也成立
3. 联合1\2，证明k~0~-k~n~均成立

**如何求解动归问题**

1. 确定动归状态

   例如：f(i, j) 代表从底边走到(i, j)点所能获得的最大值

2. 确定状态转移方程

   例如：f(i, j)=max[f(i+1, j), f(i+1, j+1)] + val(i, j) 

   理解：转移、决策（取max）

   所谓转移，就是把所有决定f(i, j)最优值的状态，放入到决策过程中

3. 正确性证明：数学归纳法

4. 程序实现

**拓扑序**

​	拓扑序是一种图形结构上的依赖顺序，一个图的拓扑序不唯一

​	拓扑序的本质作用：把图形结构变成一个一维序列，图形结构不能用循环遍历，一维序列可以

​	所有递推问题中的状态更新过程，本质上满足拓扑序

​	动归问题求解：状态之间的求解顺序必须满足拓扑序

##### 3.动态规划习题

**习题1：最长上升子序列（oj44）**

**法一**

1. 确定递推状态

   f(i) : 以i结尾的最长上升子序列长度

2. 状态转移方程

   $dp(i)=max{dp(j)} + 1   |   j < i, val[j] < val[i]$

   状态转移的时间复杂度：O(n^2^)

   后续重点：优化转移过程

3. 程序实现

```c++
#include <iostream>
#include <cstdio>
using namespace std;

#define MAX_N 1000000
int arr[MAX_N + 5];
int dp[MAX_N + 5]; //记录状态规划问题中的状态值，通常以dp命名

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d", arr+i);
    }
    int ans = 0;
    for (int i = 0; i < n; i++) {
        dp[i] = 1;
        for (int j = 0; j < i; j++) {
            if (arr[j] >= arr[i]) continue;
            dp[i] = max(dp[i], dp[j] + 1);
        }
        ans = max(ans, dp[i]);
    }
    cout << ans << endl;
    return 0; 
}
```

**法二（优化）**

声明一个数组len，len[i]中存储的值代表长度为i的最长字符串其最后一位的值

最后我们只需在len数组中找到最后一个有值的位置的下标即为最大长度

len是一个单调递增序列

1. 维护一个单调数组len,len[i]代表长度为i的序列，结尾最小值
2. dp[i]在转移的时候，在len数组中查找第一个$len[k] \ge val_i$的位置，$dp[i]=k$
3. 更新$len[k]=val_i$
4. 需要明确，len[数组是单调的
5. 在len数组中查找k，实际上就是二分算法

- 时间复杂度$O(nlog(l))$

- 程序实现

```c++
#include <iostream>
#include <cstdlib>
#include <cstring>
using namespace std;

#define MAX_N 1000000
int dp[MAX_N + 5];
int len[MAX_N + 5];

int binary_search(int *arr, int n, int x) {
    int head = 0, tail = n, mid;
    while (head < tail) {
        mid = (head + tail) >> 1;
        if (arr[mid] < x) head = mid + 1;
        else tail = mid;
    }
    return head;
}

int main() {
    int n, ans = 0, a;
    cin >> n;
    memset(len, 0x3f, sizeof(len));//存极大值
    len[0] = 0;
    for (int i = 1; i <= n; i++) {
        cin >> a;//每次读入一个数据
        dp[i] = binary_search(len, ans + 1, a);
        //二分查找找到第一个>val[i]的值
        len[dp[i]] = a;
        ans = max(dp[i], ans);
    }
    cout << ans << endl;
    return 0;
}
```

**习题2：最长公共子序列（oj45）**

1. 确定递推状态

   f(i, j) 第1个字符串取前i位，第2个取前j位的最长公共子序列长度

2. f(i, j) = 

   ​	第一种情况：s1[i]!=s2[j]

   ​	状态转移：f(i-1, j) , f(i, j-1)

   ​	第二种情况： s1[i]=s2[j]

   ​	状态转移：f(i-1, j-1) + 1

时间复杂度：O(n*m)

注意：参与决策的状态数量，是会根据条件不同而改变的

3. 程序实现

```c++
#include <iostream>
#include <string>
using namespace std;

#define MAX_N 1000
string s1, s2;
int dp[MAX_N + 5][MAX_N + 5] = {0};

int main() {
    cin >> s1 >> s2;

    for (int i = 1; i<= s1.size(); i++) {
        for (int j = 1; j <= s2.size(); j++) {
            dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            if (s1[i - 1] == s2[j - 1]) {
                dp[i][j] = max(dp[i][j], dp[i-1][j-1] + 1);
            }
        }
    }

    cout << dp[s1.size()][s2.size()] << endl;
    return 0;
}
```

**习题3：切割回文（oj46）**

1. 状态定义

   dp[i] 代表取字符串的前i位，最少分成多少段回文串

2. 状态转移方程

   dp[i] = min(dp[j]) + 1   (j+1->i位必须是一段完整的回文串)

3. 程序实现

```c++
#include <iostream>
using namespace std;

#define MAX_N 500000
int dp[MAX_N + 5];

bool is_palindrome(string &s, int i, int j) {
    while (i < j) {
        if (s[i++] != s[j--]) return false;
    }
    return true;
}

int main() {
    string s;
    cin >> s;
    dp[0] = 0;
    for (int i = 1; i <= s.size(); i++) {
        dp[i] = dp[i - 1] + 1;//最多的情况下
        for (int j = 0; j < i; j++) {
            if (is_palindrome(s, j, i - 1)) {//判断j到i-1是否是一个回文字符串
                dp[i] = min(dp[i], dp[j] + 1);
            }
        }
    }
    cout << dp[s.size()] - 1 << endl;
    return 0;
}
```

存在问题：根据状态转移，算法时间复杂度O(n^2^)，所以需要对转移阶段进行优化

###### 背包问题

**习题：0/1背包（oj47）**

1. 状态定义

   dp[i] [j] 代表前i件物品，背包上限为j的情况下，能装的价钱最大值

2. 状态转移方程

   分情况：(每件商品只有一件，v~i~代表重量，w~i~代表价钱)

   i没选：dp[i-1] [j]

   i选了：dp[i-1] [j - v~i~] + w~i~

   dp[i] [j] = max(dp[i-1] [j], dp[i-1] [j-v~i~]+w~i~)

3. 时间复杂度：$O (nm) $

4. 程序实现

```c++
#include <iostream>
using namespace std;

#define MAX_N 100
#define MAX_V 10000
int v[MAX_N + 5], w[MAX_N + 5];
int dp[2][MAX_V + 5] = {0}; //利用滚动数组

int main() {
    int V, n;
    cin >> V >> n;
    for (int i = 1; i<= n; i++) cin >> v[i] >> w[i];
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= V; j++) {
            dp[i % 2][j] = dp[(i - 1) % 2][j]; //j没有v[i]大，则一定不用装第i件物品，所以是初始化为i-1
            if (j >= v[i]) dp[i % 2][j] = max(dp[(i - 1) % 2][j], dp[(i - 1) % 2][j-v[i]] + w[i]);
        }
    }
    cout << dp[n % 2][V] << endl;
    return 0;
}
```

优化:将程序中的dp数组变成了一维

```c++
#include <iostream>
using namespace std;

#define MAX_V 10000
int dp[MAX_V + 5] = {0}; 

int main() {
    int V, n, v, w;
    cin >> V >> n;
    for (int i = 1; i <= n; i++) {
        cin >> v >> w;
        for (int j = V; j >= v; j--) {
            dp[j] = max(dp[j], dp[j-v] + w);
        }
    }
    cout << dp[V] << endl;
    return 0;
}
```

- j为什么逆序

  

- 为什么不需要v,w数组

  因为此时变成了读入一个商品，处理一个商品

- dp数组第一维为什么没了

  dp数组的状态定义并没有变，只是在代码实现的过程中去掉了一维

**习题：完全背包(oj48)**

1. 状态定义

   dp[i] [j] 代表前i件物品，背包上限为j的情况下，能装的价钱最大值

2. 状态转移方程

   分情况：(每件商品只有一件，v~i~代表重量，w~i~代表价钱)

   i没选：dp[i-1] [j]

   i选了：dp[i] [j - v~i~] + w~i~

   dp[i] [j] = max(dp[i-1] [j], dp[i] [j-v~i~]+w~i~)
   
3. 时间复杂度：$O (nm) $

4. 程序实现

```c++
#include <iostream>
using namespace std;

#define MAX_N 10000
int dp[MAX_N + 5];

int main() {
    int V, n, w, v;
    cin >> n >> V;
    for (int i = 1; i <= n; i++) {
        cin >> v >> w;
        for (int j = v; j <= V; j++) {
            dp[j] = max(dp[j], dp[j-v] + w);
        }
    }
    cout << dp[V] << endl;
    return 0;
}
```

**习题：多重背包(oj49)**

**法一**

将每一个重复物品都单做单独的一个，每一个都可以看做一个单独的0/1背包问题

```c++
#include <iostream>
using namespace std;

#define MAX_N 100000
int dp[MAX_N + 5];

int main() {
    int V, n, v, w, s;
    cin >> V >> n;
    for (int i = 1; i <= n; i++) {
        cin >> v >> w >> s;
        for (int k = 0; k < s; k++) {
            for (int j = V; j >= v; j--) {
                dp[j] = max(dp[j], dp[j - v] + w);
            }
        }
    }
    cout << dp[V] << endl;
    return 0;
}
```

**法二：优化**

- 转移过程优化

  二进制拆分法，减小数量。例如：一件物品有14件，可以将其拆分为2,4,8,7，这样无论需要能拿多少件，都可以用这四种情况来表示

  本质上，对于某一类物品，我们具体要选择多少件，才是最优答案

  普通的单一拆分法，必须要枚举1-s件的所有情况；二进制拆分法可以达到相同的效果，拆分的物品数量更少。例如：一个物品有14件，普通拆分为14件，二进制拆分法为4件，减少计算量。

- 时间复杂度：$O(n \times m \times \sum_{i=1}^{i=n}{log(s_i)})$，最优时间复杂度$O(nm)$

- 程序实现

```c++
#include <iostream>
using namespace std;

#define MAX_N 100000
int dp[MAX_N + 5];

int main() {
    int V, n, v, w, s;
    cin >> V >> n;
    for (int i = 1; i <= n; i++) {
        cin >> v >> w >> s;
        for (int k = 1; s; k *= 2) {
            if (k > s) k = s;
            s -= k;
            for (int j = V; j >= k * v; j--) {
                dp[j] = max(dp[j], dp[j - k * v] + k * w);
            }
        }
    }
    cout << dp[V] << endl;
    return 0;
}
```

**习题：扔鸡蛋问题（oj50、leetcode887）**

递归状态：

​	d[n] [m] 代表n个鸡蛋测m层楼，最小测试次数

状态转移方程：

​	dp[n] [m] = min~k~( max(dp[n-1] [k - 1],  dp[n] [m-k]) ) + 1

$$dp[n][m] = min(max\left\{\begin{aligned}&dp[n-1][k-1]+1 &鸡蛋碎了 \\ &dp[n][m-k]+1 &鸡蛋没碎\end{aligned})\right.$$

存在问题：

- 程序所使用的存储空间与楼层数量强相关

**法一**

时间复杂度：O(n*m^2^)

```c++
#include <iostream>
#include <cmath>
#include <algorithm>
using namespace std;

#define MAX_N 32
#define MAX_M 100000
int dp[MAX_N + 5][MAX_M + 5];

int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i<= m; i++) dp[1][i] = i;
    for (int i = 2; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            dp[i][j] = j;
            for (int k = 1; k <= j; k++) {
                dp[i][j] = min(dp[i][j] , max(dp[i - 1][k - 1], dp[i][j - k]) + 1);
            }
        }
    }
    cout << dp[n][m] << endl;
    return 0;
}
```

**法二**

- 转移过程优化
  去掉k的循环（即寻找最小的过程），其实可以通过计算找到最低点，而直接通过这一点就可以确定
  dp[i] [j]的值
- 时间复杂度约等于O(n*m)
  ```c++
  class Solution {
  public:
      int superEggDrop(int n, int m) {
          int dp[n + 1][m + 1];
          memset(dp, 0, sizeof(dp));
          for (int i = 1; i <= m; i++) dp[1][i] = i;
          for (int i = 2; i <= n; i++) {
              int k = 2;
              dp[i][1] = 1;
              for (int j = 2; j <= m; j++) {
                  while (k < j && dp[i - 1][k - 1] < dp[i][j - k]) ++k; //找最低点
                  dp[i][j] = max(dp[i - 1][k - 1], dp[i][j-k]) + 1;
              }
          }
          return dp[n][m];
      }
  };
  ```


**法三**

- 状态定义的优化

  由于原状态定义所需存储空间与m有关，m值域大，所以存不下

  当发现某个自变量(m)与因变量(k)存在相关性的时候，两者即可对调

  $dp[n][m]=k$重定义为$dp[n][k]=m$，代表n个鸡蛋扔k次最多测多少层楼

  由于k的值域小，例如当n=2，m=100时，k=14，（$k \le \sqrt{2m}$）可以看出k和m的关系已经为根号关系了

- 状态转移方程

  $dp[n][k]=dp[n-1][k-1]+dp[n][k-1]+1$

  代表的就是n个鸡蛋扔k次最多能测多少层楼，也是分鸡蛋碎和没碎两种情况

- 实际中改变了状态定义，将一个动态规划问题转变为递推问题

- 时间复杂度$O(n \times \sqrt{2m})$
- 程序实现

```c++
#include <iostream>
using namespace std;

#define MAX_N 32
#define MAX_K 50000
long long  dp[MAX_N + 5][MAX_K + 5];

int solve(int n, int m) {
    if (n == 1) return m;
    
    for (int i = 1; i <= MAX_K; i++) dp[1][i] = i;
    for (int i = 2; i <= n; i++) {
        for (int k = 1; k <= MAX_K; k++) {
            dp[i][k] = dp[i - 1][k - 1] + dp[i][k - 1] + 1;
        }
    }
    int k = 1;
    while (dp[n][k] < m) k++;
    return k;
}

int main() {
    int n, m;
    cin >> n >> m;
    cout << solve(n, m) << endl;
    return 0;
}
```

##### 4.动态规划的优化

一、动态规划优化的分类

1. 状态转移过程的优化，不改变状态定义，使用一些特殊的数据结构或者算法专门优化转移过程
2. 程序实现的优化，例如：0/1背包问题，状态定义没有变，转移过程也没有变
3. 状态定义优化，大量的训练，才能培养的能力，从源头进行优化
4. 状态定义->源头，转移转移过程->过程，程序实现->结果

程序优化：01背包，钱币问题，滚动数组

### 五、滑动窗口法

> 动态窗口：双指针
>
> 静态窗口

1. ol8

- 题目描述

> 在1000个数中找到乘积最大的连续13个数

```c++
#include <iostream>
using namespace std;

char num[1005];
long long ans, zero_cnt, now = 1;

int main () {
    cin >> num;
    for (int i = 0; i < 1000; i++) {
        if (i < 13) {
            now *= num[i] - '0';
        } else {
            if (num[i] == '0') {
                zero_cnt++;
            } else {
                now *= num[i] - '0';
            }
            if (num[i - 13] == '0') {
                zero_cnt--;
            } else {
                now /= num[i - 13] - '0';
            }

            if (zero_cnt == 0) {
                ans = max(ans, now);
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```

### 六、方向数组

1. ol11

- 题目描述

> 在20×20网格中相同方向（上，下，左，右或对角线）上四个相邻数字的最大乘积是多少？

方向数组四个方向

判断越界，插值

**方向：**共有上下左右和四个斜线共八个方向，在遍历数据时，为了避免重复，可以只定义四个方向，以当前数据为基准，定义的四个方向分别为(0, 1),(1,1),(1,0),(1,-1)。

**判断越界：**可以在二维数组的四周填充四排的0，这样遍历数据的时候就不存在越界的情况了

```c++
#include <iostream>
using namespace std;

int dirx[4] = {0, 1, 1, 1};//方向数组
int diry[4] = {1, 1, 0, -1};
int num[30][30], ans;

int main() {
    for (int i = 5; i < 25; i++) {
        for (int j = 5; j < 25; j++) {
            cin >> num[i][j];
        }
    }
    for (int i = 5; i < 25; i++) {//遍历所有数据
        for (int j = 5; j < 25; j++) {
            for (int k = 0; k < 4; k++) {//遍历4个方向
                int t = num[i][j];
                for (int l = 1; l < 4; l++) {//每个方向走四个步骤
                    int x = i + dirx[k] * l;
                    int y = j + diry[k] * l;
                    t *= num[x][y];
                }
                ans = max(ans, t);
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```

### 七、记忆数组、记忆化

递归+记忆化 约等于 递推

- 斐波那契数列

```c++
#include <iostream>
using namespace std;

long long num[100];

long long  fib(int n) {
    if (n == 0 || n == 1) return 1;
    if(num[n]) return num[n];
    return  num[n] = fib(n - 1) + fib(n - 2);
}

int main() {
    for (int i = 2; i < 40; i++) {
        cout << fib(i) << endl;
    }
    return 0;
}
```

- ol14

**题目描述**

> 为正整数的集合定义了以下迭代序列：
>
> n → n / 2（n是偶数）
> n →3 n + 1（n是奇数）
>
> 使用上面的规则并从13开始，我们生成以下序列：
>
> 13→40→20→10→5→16→8→4→2→1
>
> 可以看出，该序列（从13开始到1结束）包含10个项。尽管尚未证明（Collatz问题），但可以认为所有起始数字都以1结尾。
>
> 最长的链条中小于100万的哪个起始数字？

**示例代码**

```c++
#include <iostream>
using namespace std;

int num[10000000];

int func(long long n) {
    if (n == 1) return 1;
    if (n < 10000000 && num[n]) return num[n];
    int t;
    if (n % 2) {
        t = func(3 * n + 1) + 1;
    } else {
        t = func(n >> 1) + 1;
    }
    if (n < 10000000) {
        num[n] = t;
    }
    return t;
}

int main() {
    int ans = 1;
    for (int i = 2; i <= 1000000; i++) {
        if (func(ans) < func(i)) {
            ans = i;
        }
    }
    cout << ans << endl;
    return 0;
}
```

### 八、大整数运算

1. 大整数加法
- ol13

**题目描述**

> 计算100个50位大整数加法的前十位

```c++
#include <iostream>
#include <cstring>
using namespace std;

int num1[105], num2[105], sum[105] = {0};
char s1[105], s2[105];

int main() {
    for (int k = 0; k < 100; k++) {
        cin >> s1;
        num1[0] = strlen(s1); //第一个位置存储大整数位数
        for (int i = 0, j = num1[0]; i < num1[0]; i++, j--) {
            num1[j] = s1[i] - '0';
        }
        sum[0] = max(num1[0], sum[0]);
        for (int i = 1; i <= sum[0]; i++) {
            sum[i] = num1[i] + sum[i];
        }
        for (int i = 1; i <= sum[0]; i++) {
            if (sum[i] > 9) {
                sum[i + 1] += sum[i] / 10;
                sum[i] %= 10;
                if (i == sum[0]) sum[0]++;
            }
        }
    }
    for (int i = sum[0]; i > sum[0] - 10; i--) {
        cout << sum[i];
    }
    cout << endl;
    return 0;
}
```

- ol25

**题目描述**

> 求解斐波那契数列第一个拥有1000位的下标位置

```c++
#include <iostream>
#include <cstring>
using namespace std;

int func(int *n1, int *n2) {//返回数据位数是否超过1000位
    n2[0] = n1[0];
    for (int i = 1; i <= n2[0]; i++) {
        n2[i] += n1[i];
        if (n2[i] > 9) {
            n2[i+1]++;
            n2[i] -= 10;
            if (i == n2[0]) n2[0]++;
        }
    }
    return n2[0] >= 1000;
}

int main() {
    int num[2][1100] = {{1, 1}, {1, 1}};//使用两个大整数数组，存储起始元素个数及第一个元素
    int a = 0, b = 1;
    for (int i = 3; 1; i++) {
        if (func(num[a], num[b])) {
            cout << i << endl;
            break;
        }
        swap(a, b);//两个数组不断循环相加
    }
    return 0;
}
```

2. 大整数乘法

```c++
#include <iostream>
#include <cstring>
using namespace std;

int num1[1005], num2[1005], sum[1005];
char s1[1005], s2[1005];

int main() {
    cin >> s1 >> s2;
    num1[0] = strlen(s1);
    num2[0] = strlen(s2);

    for (int i = 0, j = num1[0]; i < num1[0]; i++, j--) {
        num1[j] = s1[i] - '0';
    }
    for (int i = 0, j = num2[0]; i < num2[0]; i++, j--) {
        num2[j] = s2[i] - '0';
    }

    sum[0] = num1[0] + num2[0] - 1;
    for (int i = 1; i <= num1[0]; i++) {
        for (int j = 1; j <= num2[0]; j++) {
            sum[i + j - 1] += num1[i] * num2[j];
        }
    }
    for (int i = 1; i <= sum[0]; i++) {
        if (sum[i] > 9) {
            sum[i + 1] += sum[i] / 10;
            sum[i] %= 10;
            if (i == sum[0]) sum[0]++;
        }
    }
    for (int i = sum[0]; i > 0; i--) {
        cout << sum[i];
    }
    cout << endl;

    return 0;
}
```

### 九、排序

- 自定义排序规则

oj380 大统领投票

封装结构体数组，每一位存储票数和总统的编号的节点

每次读入字符串和编号

然后定义排序规则对结构体数组进行排序，返回最大值

```c++
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

struct node {
    int num;
    string s;
};

int n;
node p[105];

bool cmp(node &a, node &b) {//定义排序规则
    if (a.s.size() == b.s.size()) {
        return a.s > b.s;
    }
    return a.s.size() > b.s.size();
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> p[i].s;
        p[i].num = i;
    }
    sort(p + 1, p + n, cmp);
    cout << p[1].num << endl << p[1].s << endl;
    return 0;
}
```

### 十、查找

##### 二分查找

- 二分查找的特殊情况

> 00000000011111111		//寻找第一个1

```c++
while (l != r) {
    int mid = (l + r) >> 1;
    if (n[mid] == 0) {
        l = mid + 1;
    } else {
        r = mid;
    }
}
return l;
```

> 11111111100000000		//寻找最后一个1

```c++
while (l != r) {
    int mid = (l + r + 1) >> 1;//防止死循环
    if (n[mid] == 1) {
        l = mid;
    } else {
        r = mid + 1;
    }
}
return l - 1;
```

- 习题oj387

```c++
#include <iostream>
#include <algorithm>
using namespace std;

struct node {
    int num, cnt;
};

node p[105];
int n, m;

bool cmp(const node& a, const node& b) {
    return a.num < b.num;
}

int main() {
    cin >> n >> m;
    for (int  i = 0; i < n; i++) {
        cin >> p[i].num;
        p[i].cnt = i + 1;
    }
    p[n].num = 2100000000;
    p[n].cnt = 0;
    sort(p, p + n + 1, cmp);
    for (int i = 0; i < m; i++) {
        int t, l = 0, r = n;
        cin >> t;
        while (l - r) {
            int mid = (l + r) >> 1;
            if (p[mid].num >= t) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        cout << p[l].cnt << endl;
    }
    return 0;
}
```

### 十一、前缀和

前缀和：可以快速求解区间和问题

创建一个前缀和数组：第i位都等于从第0位加到第i位的值，第0位初始化为0

如果想获取区间i到j的和值，那么在前缀和中只需用S[i+1]-S[j]即可，初始化的目的是避免在求解第0位到第j位的和值